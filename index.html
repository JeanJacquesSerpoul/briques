<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jeu de Casse-Briques</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }
        
        canvas {
            background: #000;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .score-display {
            margin-bottom: 20px;
            font-size: 20px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        .game-over h2 {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="score-display">Score: <span id="score">0</span> | Vies: <span id="lives">3</span></div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <button id="startButton">Démarrer</button>
        <button id="resetButton">Recommencer</button>
    </div>
    <div class="game-over" id="gameOver">
        <h2>Partie terminée!</h2>
        <p>Score final: <span id="finalScore">0</span></p>
        <button id="restartButton">Rejouer</button>
    </div>

    <script>
        // Configuration du jeu
        const config = {
            ballRadius: 10,
            paddleHeight: 15,
            paddleWidth: 80,
            brickRowCount: 5,
            brickColumnCount: 8,
            brickWidth: 75,
            brickHeight: 20,
            brickPadding: 10,
            brickOffsetTop: 30,
            brickOffsetLeft: 30,
            ballSpeed: 4,
            paddleSpeed: 7
        };

        // Variables du jeu
        let canvas, ctx;
        let ballX, ballY, ballDX, ballDY;
        let paddleX;
        let bricks = [];
        let score = 0;
        let lives = 3;
        let gameStarted = false;
        let gameOver = false;
        let canvasWidth, canvasHeight;

        // Initialisation du jeu
        function initGame() {
            // Configurer le canvas
            canvas = document.getElementById("gameCanvas");
            ctx = canvas.getContext("2d");
            
            // Ajuster la taille du canvas en fonction de la fenêtre
            resizeCanvas();
            
            // Initialiser la position de la balle et de la raquette
            ballX = canvasWidth / 2;
            ballY = canvasHeight - 30;
            ballDX = config.ballSpeed;
            ballDY = -config.ballSpeed;
            paddleX = (canvasWidth - config.paddleWidth) / 2;
            
            // Créer les briques
            createBricks();
            
            // Redessiner tout
            draw();
            
            // Ajouter les événements pour déplacer la raquette
            addEventListeners();
            
            // Réinitialiser le score et les vies
            score = 0;
            lives = 3;
            updateScoreDisplay();
            
            // Cacher le message de fin de jeu
            document.getElementById("gameOver").style.display = "none";
            
            // Indiquer que le jeu est prêt mais pas encore démarré
            gameStarted = false;
            gameOver = false;
        }
        
        // Ajuster la taille du canvas
        function resizeCanvas() {
            // Limiter la largeur à 90% de la fenêtre ou 800px maximum
            canvasWidth = Math.min(window.innerWidth * 0.9, 800);
            
            // Hauteur proportionnelle à la largeur (aspect ratio 4:3)
            canvasHeight = canvasWidth * 0.75;
            
            // Mettre à jour les dimensions du canvas
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Mettre à jour la largeur des briques en fonction de la taille du canvas
            config.brickWidth = (canvasWidth - 2 * config.brickOffsetLeft - (config.brickColumnCount - 1) * config.brickPadding) / config.brickColumnCount;
        }

        // Créer les briques
        function createBricks() {
            bricks = [];
            for (let c = 0; c < config.brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < config.brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }
        }

        // Dessiner une brique
        function drawBricks() {
            for (let c = 0; c < config.brickColumnCount; c++) {
                for (let r = 0; r < config.brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (config.brickWidth + config.brickPadding) + config.brickOffsetLeft;
                        const brickY = r * (config.brickHeight + config.brickPadding) + config.brickOffsetTop;
                        
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, config.brickWidth, config.brickHeight);
                        
                        // Couleurs différentes pour chaque rangée
                        const colors = ["#FF4136", "#FF851B", "#FFDC00", "#2ECC40", "#0074D9"];
                        ctx.fillStyle = colors[r];
                        
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        // Dessiner la balle
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ballX, ballY, config.ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#FFFFFF";
            ctx.fill();
            ctx.closePath();
        }

        // Dessiner la raquette
        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvasHeight - config.paddleHeight, config.paddleWidth, config.paddleHeight);
            ctx.fillStyle = "#4CAF50";
            ctx.fill();
            ctx.closePath();
        }

        // Dessiner le jeu
        function draw() {
            // Effacer le canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Dessiner les éléments
            drawBricks();
            drawBall();
            drawPaddle();
            
            // Vérifier les collisions avec les briques
            collisionDetection();
            
            // Mettre à jour la position de la balle si le jeu est en cours
            if (gameStarted && !gameOver) {
                // Collision avec les bords latéraux
                if (ballX + ballDX > canvasWidth - config.ballRadius || ballX + ballDX < config.ballRadius) {
                    ballDX = -ballDX;
                }
                
                // Collision avec le bord supérieur
                if (ballY + ballDY < config.ballRadius) {
                    ballDY = -ballDY;
                } else if (ballY + ballDY > canvasHeight - config.ballRadius) {
                    // Collision avec la raquette
                    if (ballX > paddleX && ballX < paddleX + config.paddleWidth) {
                        // Modifier la direction en fonction de l'endroit où la balle a touché la raquette
                        const hitPosition = (ballX - paddleX) / config.paddleWidth;
                        const angle = (hitPosition - 0.5) * Math.PI / 2; // Entre -PI/4 et PI/4
                        const speed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
                        
                        ballDX = speed * Math.sin(angle);
                        ballDY = -speed * Math.cos(angle);
                    } else {
                        // Balle perdue
                        lives--;
                        updateScoreDisplay();
                        
                        if (lives === 0) {
                            // Fin de la partie
                            endGame();
                        } else {
                            // Réinitialiser la position de la balle
                            ballX = canvasWidth / 2;
                            ballY = canvasHeight - 30;
                            ballDX = config.ballSpeed;
                            ballDY = -config.ballSpeed;
                            paddleX = (canvasWidth - config.paddleWidth) / 2;
                        }
                    }
                }
                
                // Mettre à jour la position de la balle
                ballX += ballDX;
                ballY += ballDY;
            }
            
            // Continuer l'animation
            if (!gameOver) {
                requestAnimationFrame(draw);
            }
        }

        // Détecter les collisions avec les briques
        function collisionDetection() {
            for (let c = 0; c < config.brickColumnCount; c++) {
                for (let r = 0; r < config.brickRowCount; r++) {
                    const brick = bricks[c][r];
                    
                    if (brick.status === 1) {
                        // Vérifier si la balle touche la brique
                        if (ballX > brick.x && ballX < brick.x + config.brickWidth &&
                            ballY > brick.y && ballY < brick.y + config.brickHeight) {
                            ballDY = -ballDY;
                            brick.status = 0;
                            score += 10;
                            updateScoreDisplay();
                            
                            // Vérifier si toutes les briques sont cassées
                            checkWin();
                        }
                    }
                }
            }
        }

        // Vérifier si le joueur a gagné
        function checkWin() {
            let remainingBricks = 0;
            
            for (let c = 0; c < config.brickColumnCount; c++) {
                for (let r = 0; r < config.brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        remainingBricks++;
                    }
                }
            }
            
            if (remainingBricks === 0) {
                // Victoire!
                gameStarted = false;
                gameOver = true;
                
                document.getElementById("gameOver").style.display = "block";
                document.getElementById("finalScore").textContent = score;
            }
        }

        // Mettre à jour l'affichage du score et des vies
        function updateScoreDisplay() {
            document.getElementById("score").textContent = score;
            document.getElementById("lives").textContent = lives;
        }

        // Fin de la partie
        function endGame() {
            gameStarted = false;
            gameOver = true;
            
            document.getElementById("gameOver").style.display = "block";
            document.getElementById("finalScore").textContent = score;
        }

        // Ajouter les événements
        function addEventListeners() {
            // Événements pour le clavier
            document.addEventListener("keydown", keyDownHandler);
            document.addEventListener("keyup", keyUpHandler);
            
            // Événements pour le tactile/mobile
            canvas.addEventListener("touchmove", touchMoveHandler);
            
            // Événements pour la souris
            canvas.addEventListener("mousemove", mouseMoveHandler);
            
            // Boutons
            document.getElementById("startButton").addEventListener("click", startGame);
            document.getElementById("resetButton").addEventListener("click", initGame);
            document.getElementById("restartButton").addEventListener("click", initGame);
            
            // Redimensionnement de la fenêtre
            window.addEventListener("resize", function() {
                resizeCanvas();
                if (!gameStarted) {
                    draw();
                }
            });
        }

        // Gérer les touches du clavier (appui)
        let rightPressed = false;
        let leftPressed = false;
        
        function keyDownHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = true;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = true;
            } else if (e.key === " " || e.key === "Spacebar") {
                if (!gameStarted && !gameOver) {
                    startGame();
                }
            }
        }

        // Gérer les touches du clavier (relâchement)
        function keyUpHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = false;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = false;
            }
        }

        // Gérer le mouvement de la souris
        function mouseMoveHandler(e) {
            const relativeX = e.clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < canvasWidth) {
                paddleX = relativeX - config.paddleWidth / 2;
                
                // Limiter la position de la raquette
                if (paddleX < 0) {
                    paddleX = 0;
                } else if (paddleX > canvasWidth - config.paddleWidth) {
                    paddleX = canvasWidth - config.paddleWidth;
                }
            }
        }

        // Gérer le mouvement tactile
        function touchMoveHandler(e) {
            e.preventDefault();
            const relativeX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < canvasWidth) {
                paddleX = relativeX - config.paddleWidth / 2;
                
                // Limiter la position de la raquette
                if (paddleX < 0) {
                    paddleX = 0;
                } else if (paddleX > canvasWidth - config.paddleWidth) {
                    paddleX = canvasWidth - config.paddleWidth;
                }
            }
        }

        // Démarrer le jeu
        function startGame() {
            if (!gameStarted && !gameOver) {
                gameStarted = true;
                
                // Mettre à jour la raquette selon les touches
                function updatePaddle() {
                    if (rightPressed && paddleX < canvasWidth - config.paddleWidth) {
                        paddleX += config.paddleSpeed;
                    } else if (leftPressed && paddleX > 0) {
                        paddleX -= config.paddleSpeed;
                    }
                    
                    // Continuer la mise à jour si le jeu est en cours
                    if (gameStarted && !gameOver) {
                        requestAnimationFrame(updatePaddle);
                    }
                }
                
                // Démarrer la mise à jour de la raquette
                updatePaddle();
            }
        }

        // Initialiser le jeu au chargement
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>